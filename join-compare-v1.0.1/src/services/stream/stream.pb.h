// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stream.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stream_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stream_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stream_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stream_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_stream_2eproto;
namespace stream {
class BDMessage;
struct BDMessageDefaultTypeInternal;
extern BDMessageDefaultTypeInternal _BDMessage_default_instance_;
class BatchTuple;
struct BatchTupleDefaultTypeInternal;
extern BatchTupleDefaultTypeInternal _BatchTuple_default_instance_;
class HashJoinerInfo;
struct HashJoinerInfoDefaultTypeInternal;
extern HashJoinerInfoDefaultTypeInternal _HashJoinerInfo_default_instance_;
class ProcessorsInfo;
struct ProcessorsInfoDefaultTypeInternal;
extern ProcessorsInfoDefaultTypeInternal _ProcessorsInfo_default_instance_;
class SFRInfo;
struct SFRInfoDefaultTypeInternal;
extern SFRInfoDefaultTypeInternal _SFRInfo_default_instance_;
class SMessage;
struct SMessageDefaultTypeInternal;
extern SMessageDefaultTypeInternal _SMessage_default_instance_;
class StatisticMsg;
struct StatisticMsgDefaultTypeInternal;
extern StatisticMsgDefaultTypeInternal _StatisticMsg_default_instance_;
class StreamInfo;
struct StreamInfoDefaultTypeInternal;
extern StreamInfoDefaultTypeInternal _StreamInfo_default_instance_;
class StreamSummary;
struct StreamSummaryDefaultTypeInternal;
extern StreamSummaryDefaultTypeInternal _StreamSummary_default_instance_;
class TableReaderInfo;
struct TableReaderInfoDefaultTypeInternal;
extern TableReaderInfoDefaultTypeInternal _TableReaderInfo_default_instance_;
class Tuple;
struct TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
}  // namespace stream
PROTOBUF_NAMESPACE_OPEN
template<> ::stream::BDMessage* Arena::CreateMaybeMessage<::stream::BDMessage>(Arena*);
template<> ::stream::BatchTuple* Arena::CreateMaybeMessage<::stream::BatchTuple>(Arena*);
template<> ::stream::HashJoinerInfo* Arena::CreateMaybeMessage<::stream::HashJoinerInfo>(Arena*);
template<> ::stream::ProcessorsInfo* Arena::CreateMaybeMessage<::stream::ProcessorsInfo>(Arena*);
template<> ::stream::SFRInfo* Arena::CreateMaybeMessage<::stream::SFRInfo>(Arena*);
template<> ::stream::SMessage* Arena::CreateMaybeMessage<::stream::SMessage>(Arena*);
template<> ::stream::StatisticMsg* Arena::CreateMaybeMessage<::stream::StatisticMsg>(Arena*);
template<> ::stream::StreamInfo* Arena::CreateMaybeMessage<::stream::StreamInfo>(Arena*);
template<> ::stream::StreamSummary* Arena::CreateMaybeMessage<::stream::StreamSummary>(Arena*);
template<> ::stream::TableReaderInfo* Arena::CreateMaybeMessage<::stream::TableReaderInfo>(Arena*);
template<> ::stream::Tuple* Arena::CreateMaybeMessage<::stream::Tuple>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace stream {

enum StreamInfo_StreamType : int {
  StreamInfo_StreamType_LOCAL = 0,
  StreamInfo_StreamType_REMOTE = 1,
  StreamInfo_StreamType_StreamInfo_StreamType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamInfo_StreamType_StreamInfo_StreamType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamInfo_StreamType_IsValid(int value);
constexpr StreamInfo_StreamType StreamInfo_StreamType_StreamType_MIN = StreamInfo_StreamType_LOCAL;
constexpr StreamInfo_StreamType StreamInfo_StreamType_StreamType_MAX = StreamInfo_StreamType_REMOTE;
constexpr int StreamInfo_StreamType_StreamType_ARRAYSIZE = StreamInfo_StreamType_StreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamInfo_StreamType_descriptor();
template<typename T>
inline const std::string& StreamInfo_StreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamInfo_StreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamInfo_StreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamInfo_StreamType_descriptor(), enum_t_value);
}
inline bool StreamInfo_StreamType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamInfo_StreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamInfo_StreamType>(
    StreamInfo_StreamType_descriptor(), name, value);
}
enum TableReaderInfo_RouterType : int {
  TableReaderInfo_RouterType_HASH = 0,
  TableReaderInfo_RouterType_AVERAGE = 1,
  TableReaderInfo_RouterType_NATIVE = 2,
  TableReaderInfo_RouterType_BALANCE = 3,
  TableReaderInfo_RouterType_FLOWSMALL = 4,
  TableReaderInfo_RouterType_FLOWBIG = 5,
  TableReaderInfo_RouterType_LDSKETCH = 6,
  TableReaderInfo_RouterType_TableReaderInfo_RouterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TableReaderInfo_RouterType_TableReaderInfo_RouterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TableReaderInfo_RouterType_IsValid(int value);
constexpr TableReaderInfo_RouterType TableReaderInfo_RouterType_RouterType_MIN = TableReaderInfo_RouterType_HASH;
constexpr TableReaderInfo_RouterType TableReaderInfo_RouterType_RouterType_MAX = TableReaderInfo_RouterType_LDSKETCH;
constexpr int TableReaderInfo_RouterType_RouterType_ARRAYSIZE = TableReaderInfo_RouterType_RouterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TableReaderInfo_RouterType_descriptor();
template<typename T>
inline const std::string& TableReaderInfo_RouterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TableReaderInfo_RouterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TableReaderInfo_RouterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TableReaderInfo_RouterType_descriptor(), enum_t_value);
}
inline bool TableReaderInfo_RouterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TableReaderInfo_RouterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TableReaderInfo_RouterType>(
    TableReaderInfo_RouterType_descriptor(), name, value);
}
enum TableReaderInfo_TableReaderType : int {
  TableReaderInfo_TableReaderType_SMALL = 0,
  TableReaderInfo_TableReaderType_BIG = 1,
  TableReaderInfo_TableReaderType_TableReaderInfo_TableReaderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TableReaderInfo_TableReaderType_TableReaderInfo_TableReaderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TableReaderInfo_TableReaderType_IsValid(int value);
constexpr TableReaderInfo_TableReaderType TableReaderInfo_TableReaderType_TableReaderType_MIN = TableReaderInfo_TableReaderType_SMALL;
constexpr TableReaderInfo_TableReaderType TableReaderInfo_TableReaderType_TableReaderType_MAX = TableReaderInfo_TableReaderType_BIG;
constexpr int TableReaderInfo_TableReaderType_TableReaderType_ARRAYSIZE = TableReaderInfo_TableReaderType_TableReaderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TableReaderInfo_TableReaderType_descriptor();
template<typename T>
inline const std::string& TableReaderInfo_TableReaderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TableReaderInfo_TableReaderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TableReaderInfo_TableReaderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TableReaderInfo_TableReaderType_descriptor(), enum_t_value);
}
inline bool TableReaderInfo_TableReaderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TableReaderInfo_TableReaderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TableReaderInfo_TableReaderType>(
    TableReaderInfo_TableReaderType_descriptor(), name, value);
}
enum HashJoinerInfo_HJType : int {
  HashJoinerInfo_HJType_BASE = 0,
  HashJoinerInfo_HJType_PNR = 1,
  HashJoinerInfo_HJType_PRPD = 2,
  HashJoinerInfo_HJType_BNR = 3,
  HashJoinerInfo_HJType_FLOWJOIN = 4,
  HashJoinerInfo_HJType_HashJoinerInfo_HJType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HashJoinerInfo_HJType_HashJoinerInfo_HJType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HashJoinerInfo_HJType_IsValid(int value);
constexpr HashJoinerInfo_HJType HashJoinerInfo_HJType_HJType_MIN = HashJoinerInfo_HJType_BASE;
constexpr HashJoinerInfo_HJType HashJoinerInfo_HJType_HJType_MAX = HashJoinerInfo_HJType_FLOWJOIN;
constexpr int HashJoinerInfo_HJType_HJType_ARRAYSIZE = HashJoinerInfo_HJType_HJType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashJoinerInfo_HJType_descriptor();
template<typename T>
inline const std::string& HashJoinerInfo_HJType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HashJoinerInfo_HJType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HashJoinerInfo_HJType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HashJoinerInfo_HJType_descriptor(), enum_t_value);
}
inline bool HashJoinerInfo_HJType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashJoinerInfo_HJType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HashJoinerInfo_HJType>(
    HashJoinerInfo_HJType_descriptor(), name, value);
}
// ===================================================================

class StatisticMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.StatisticMsg) */ {
 public:
  inline StatisticMsg() : StatisticMsg(nullptr) {}
  ~StatisticMsg() override;
  explicit constexpr StatisticMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatisticMsg(const StatisticMsg& from);
  StatisticMsg(StatisticMsg&& from) noexcept
    : StatisticMsg() {
    *this = ::std::move(from);
  }

  inline StatisticMsg& operator=(const StatisticMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatisticMsg& operator=(StatisticMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatisticMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatisticMsg* internal_default_instance() {
    return reinterpret_cast<const StatisticMsg*>(
               &_StatisticMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StatisticMsg& a, StatisticMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(StatisticMsg* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatisticMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatisticMsg* New() const final {
    return new StatisticMsg();
  }

  StatisticMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatisticMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatisticMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatisticMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatisticMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.StatisticMsg";
  }
  protected:
  explicit StatisticMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmallSkewkeysFieldNumber = 4,
    kBigSkewkeysFieldNumber = 5,
    kNetworkPhase1FieldNumber = 1,
    kNetworkPhase2FieldNumber = 2,
    kResultCountsFieldNumber = 3,
  };
  // repeated .stream.Tuple small_skewkeys = 4;
  int small_skewkeys_size() const;
  private:
  int _internal_small_skewkeys_size() const;
  public:
  void clear_small_skewkeys();
  ::stream::Tuple* mutable_small_skewkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
      mutable_small_skewkeys();
  private:
  const ::stream::Tuple& _internal_small_skewkeys(int index) const;
  ::stream::Tuple* _internal_add_small_skewkeys();
  public:
  const ::stream::Tuple& small_skewkeys(int index) const;
  ::stream::Tuple* add_small_skewkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
      small_skewkeys() const;

  // repeated .stream.Tuple big_skewkeys = 5;
  int big_skewkeys_size() const;
  private:
  int _internal_big_skewkeys_size() const;
  public:
  void clear_big_skewkeys();
  ::stream::Tuple* mutable_big_skewkeys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
      mutable_big_skewkeys();
  private:
  const ::stream::Tuple& _internal_big_skewkeys(int index) const;
  ::stream::Tuple* _internal_add_big_skewkeys();
  public:
  const ::stream::Tuple& big_skewkeys(int index) const;
  ::stream::Tuple* add_big_skewkeys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
      big_skewkeys() const;

  // int64 network_phase1 = 1;
  void clear_network_phase1();
  ::PROTOBUF_NAMESPACE_ID::int64 network_phase1() const;
  void set_network_phase1(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_network_phase1() const;
  void _internal_set_network_phase1(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 network_phase2 = 2;
  void clear_network_phase2();
  ::PROTOBUF_NAMESPACE_ID::int64 network_phase2() const;
  void set_network_phase2(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_network_phase2() const;
  void _internal_set_network_phase2(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 result_counts = 3;
  void clear_result_counts();
  ::PROTOBUF_NAMESPACE_ID::int64 result_counts() const;
  void set_result_counts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_result_counts() const;
  void _internal_set_result_counts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:stream.StatisticMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple > small_skewkeys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple > big_skewkeys_;
  ::PROTOBUF_NAMESPACE_ID::int64 network_phase1_;
  ::PROTOBUF_NAMESPACE_ID::int64 network_phase2_;
  ::PROTOBUF_NAMESPACE_ID::int64 result_counts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class StreamSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.StreamSummary) */ {
 public:
  inline StreamSummary() : StreamSummary(nullptr) {}
  ~StreamSummary() override;
  explicit constexpr StreamSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamSummary(const StreamSummary& from);
  StreamSummary(StreamSummary&& from) noexcept
    : StreamSummary() {
    *this = ::std::move(from);
  }

  inline StreamSummary& operator=(const StreamSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamSummary& operator=(StreamSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamSummary* internal_default_instance() {
    return reinterpret_cast<const StreamSummary*>(
               &_StreamSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StreamSummary& a, StreamSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamSummary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamSummary* New() const final {
    return new StreamSummary();
  }

  StreamSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.StreamSummary";
  }
  protected:
  explicit StreamSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int64 count = 1;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:stream.StreamSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.Tuple) */ {
 public:
  inline Tuple() : Tuple(nullptr) {}
  ~Tuple() override;
  explicit constexpr Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tuple(const Tuple& from);
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tuple& operator=(Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Tuple* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tuple* New() const final {
    return new Tuple();
  }

  Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tuple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.Tuple";
  }
  protected:
  explicit Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:stream.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class BatchTuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.BatchTuple) */ {
 public:
  inline BatchTuple() : BatchTuple(nullptr) {}
  ~BatchTuple() override;
  explicit constexpr BatchTuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchTuple(const BatchTuple& from);
  BatchTuple(BatchTuple&& from) noexcept
    : BatchTuple() {
    *this = ::std::move(from);
  }

  inline BatchTuple& operator=(const BatchTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTuple& operator=(BatchTuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchTuple* internal_default_instance() {
    return reinterpret_cast<const BatchTuple*>(
               &_BatchTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BatchTuple& a, BatchTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTuple* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchTuple* New() const final {
    return new BatchTuple();
  }

  BatchTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchTuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchTuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchTuple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchTuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.BatchTuple";
  }
  protected:
  explicit BatchTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 3,
    kEmptyFieldNumber = 1,
  };
  // repeated .stream.Tuple tuples = 3;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::stream::Tuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
      mutable_tuples();
  private:
  const ::stream::Tuple& _internal_tuples(int index) const;
  ::stream::Tuple* _internal_add_tuples();
  public:
  const ::stream::Tuple& tuples(int index) const;
  ::stream::Tuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
      tuples() const;

  // bool empty = 1;
  void clear_empty();
  bool empty() const;
  void set_empty(bool value);
  private:
  bool _internal_empty() const;
  void _internal_set_empty(bool value);
  public:

  // @@protoc_insertion_point(class_scope:stream.BatchTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple > tuples_;
  bool empty_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class SMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.SMessage) */ {
 public:
  inline SMessage() : SMessage(nullptr) {}
  ~SMessage() override;
  explicit constexpr SMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMessage(const SMessage& from);
  SMessage(SMessage&& from) noexcept
    : SMessage() {
    *this = ::std::move(from);
  }

  inline SMessage& operator=(const SMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMessage& operator=(SMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMessage* internal_default_instance() {
    return reinterpret_cast<const SMessage*>(
               &_SMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SMessage& a, SMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SMessage* New() const final {
    return new SMessage();
  }

  SMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.SMessage";
  }
  protected:
  explicit SMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkewKeysFieldNumber = 2,
    kBatchTuplesFieldNumber = 3,
    kStreamIdFieldNumber = 1,
  };
  // repeated string skew_keys = 2;
  int skew_keys_size() const;
  private:
  int _internal_skew_keys_size() const;
  public:
  void clear_skew_keys();
  const std::string& skew_keys(int index) const;
  std::string* mutable_skew_keys(int index);
  void set_skew_keys(int index, const std::string& value);
  void set_skew_keys(int index, std::string&& value);
  void set_skew_keys(int index, const char* value);
  void set_skew_keys(int index, const char* value, size_t size);
  std::string* add_skew_keys();
  void add_skew_keys(const std::string& value);
  void add_skew_keys(std::string&& value);
  void add_skew_keys(const char* value);
  void add_skew_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& skew_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_skew_keys();
  private:
  const std::string& _internal_skew_keys(int index) const;
  std::string* _internal_add_skew_keys();
  public:

  // .stream.BatchTuple batch_tuples = 3;
  bool has_batch_tuples() const;
  private:
  bool _internal_has_batch_tuples() const;
  public:
  void clear_batch_tuples();
  const ::stream::BatchTuple& batch_tuples() const;
  PROTOBUF_MUST_USE_RESULT ::stream::BatchTuple* release_batch_tuples();
  ::stream::BatchTuple* mutable_batch_tuples();
  void set_allocated_batch_tuples(::stream::BatchTuple* batch_tuples);
  private:
  const ::stream::BatchTuple& _internal_batch_tuples() const;
  ::stream::BatchTuple* _internal_mutable_batch_tuples();
  public:
  void unsafe_arena_set_allocated_batch_tuples(
      ::stream::BatchTuple* batch_tuples);
  ::stream::BatchTuple* unsafe_arena_release_batch_tuples();

  // int32 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:stream.SMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> skew_keys_;
  ::stream::BatchTuple* batch_tuples_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class BDMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.BDMessage) */ {
 public:
  inline BDMessage() : BDMessage(nullptr) {}
  ~BDMessage() override;
  explicit constexpr BDMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BDMessage(const BDMessage& from);
  BDMessage(BDMessage&& from) noexcept
    : BDMessage() {
    *this = ::std::move(from);
  }

  inline BDMessage& operator=(const BDMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BDMessage& operator=(BDMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BDMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BDMessage* internal_default_instance() {
    return reinterpret_cast<const BDMessage*>(
               &_BDMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BDMessage& a, BDMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BDMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BDMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BDMessage* New() const final {
    return new BDMessage();
  }

  BDMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BDMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BDMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BDMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BDMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.BDMessage";
  }
  protected:
  explicit BDMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeedKeysFieldNumber = 2,
    kDoneKeysFieldNumber = 3,
    kBatchTuplesFieldNumber = 4,
    kStreamIdFieldNumber = 1,
    kCloseFieldNumber = 5,
  };
  // repeated string need_keys = 2;
  int need_keys_size() const;
  private:
  int _internal_need_keys_size() const;
  public:
  void clear_need_keys();
  const std::string& need_keys(int index) const;
  std::string* mutable_need_keys(int index);
  void set_need_keys(int index, const std::string& value);
  void set_need_keys(int index, std::string&& value);
  void set_need_keys(int index, const char* value);
  void set_need_keys(int index, const char* value, size_t size);
  std::string* add_need_keys();
  void add_need_keys(const std::string& value);
  void add_need_keys(std::string&& value);
  void add_need_keys(const char* value);
  void add_need_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& need_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_need_keys();
  private:
  const std::string& _internal_need_keys(int index) const;
  std::string* _internal_add_need_keys();
  public:

  // repeated string done_keys = 3;
  int done_keys_size() const;
  private:
  int _internal_done_keys_size() const;
  public:
  void clear_done_keys();
  const std::string& done_keys(int index) const;
  std::string* mutable_done_keys(int index);
  void set_done_keys(int index, const std::string& value);
  void set_done_keys(int index, std::string&& value);
  void set_done_keys(int index, const char* value);
  void set_done_keys(int index, const char* value, size_t size);
  std::string* add_done_keys();
  void add_done_keys(const std::string& value);
  void add_done_keys(std::string&& value);
  void add_done_keys(const char* value);
  void add_done_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& done_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_done_keys();
  private:
  const std::string& _internal_done_keys(int index) const;
  std::string* _internal_add_done_keys();
  public:

  // .stream.BatchTuple batch_tuples = 4;
  bool has_batch_tuples() const;
  private:
  bool _internal_has_batch_tuples() const;
  public:
  void clear_batch_tuples();
  const ::stream::BatchTuple& batch_tuples() const;
  PROTOBUF_MUST_USE_RESULT ::stream::BatchTuple* release_batch_tuples();
  ::stream::BatchTuple* mutable_batch_tuples();
  void set_allocated_batch_tuples(::stream::BatchTuple* batch_tuples);
  private:
  const ::stream::BatchTuple& _internal_batch_tuples() const;
  ::stream::BatchTuple* _internal_mutable_batch_tuples();
  public:
  void unsafe_arena_set_allocated_batch_tuples(
      ::stream::BatchTuple* batch_tuples);
  ::stream::BatchTuple* unsafe_arena_release_batch_tuples();

  // int32 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool close = 5;
  void clear_close();
  bool close() const;
  void set_close(bool value);
  private:
  bool _internal_close() const;
  void _internal_set_close(bool value);
  public:

  // @@protoc_insertion_point(class_scope:stream.BDMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> need_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> done_keys_;
  ::stream::BatchTuple* batch_tuples_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  bool close_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class StreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.StreamInfo) */ {
 public:
  inline StreamInfo() : StreamInfo(nullptr) {}
  ~StreamInfo() override;
  explicit constexpr StreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInfo(const StreamInfo& from);
  StreamInfo(StreamInfo&& from) noexcept
    : StreamInfo() {
    *this = ::std::move(from);
  }

  inline StreamInfo& operator=(const StreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfo& operator=(StreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInfo* internal_default_instance() {
    return reinterpret_cast<const StreamInfo*>(
               &_StreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamInfo& a, StreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamInfo* New() const final {
    return new StreamInfo();
  }

  StreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.StreamInfo";
  }
  protected:
  explicit StreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StreamInfo_StreamType StreamType;
  static constexpr StreamType LOCAL =
    StreamInfo_StreamType_LOCAL;
  static constexpr StreamType REMOTE =
    StreamInfo_StreamType_REMOTE;
  static inline bool StreamType_IsValid(int value) {
    return StreamInfo_StreamType_IsValid(value);
  }
  static constexpr StreamType StreamType_MIN =
    StreamInfo_StreamType_StreamType_MIN;
  static constexpr StreamType StreamType_MAX =
    StreamInfo_StreamType_StreamType_MAX;
  static constexpr int StreamType_ARRAYSIZE =
    StreamInfo_StreamType_StreamType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StreamType_descriptor() {
    return StreamInfo_StreamType_descriptor();
  }
  template<typename T>
  static inline const std::string& StreamType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StreamType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StreamType_Name.");
    return StreamInfo_StreamType_Name(enum_t_value);
  }
  static inline bool StreamType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StreamType* value) {
    return StreamInfo_StreamType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServerAddressFieldNumber = 3,
    kStreamIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string server_address = 3;
  void clear_server_address();
  const std::string& server_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_server_address();
  void set_allocated_server_address(std::string* server_address);
  private:
  const std::string& _internal_server_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_address(const std::string& value);
  std::string* _internal_mutable_server_address();
  public:

  // int32 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .stream.StreamInfo.StreamType type = 2;
  void clear_type();
  ::stream::StreamInfo_StreamType type() const;
  void set_type(::stream::StreamInfo_StreamType value);
  private:
  ::stream::StreamInfo_StreamType _internal_type() const;
  void _internal_set_type(::stream::StreamInfo_StreamType value);
  public:

  // @@protoc_insertion_point(class_scope:stream.StreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_address_;
  ::PROTOBUF_NAMESPACE_ID::int32 stream_id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class TableReaderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.TableReaderInfo) */ {
 public:
  inline TableReaderInfo() : TableReaderInfo(nullptr) {}
  ~TableReaderInfo() override;
  explicit constexpr TableReaderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableReaderInfo(const TableReaderInfo& from);
  TableReaderInfo(TableReaderInfo&& from) noexcept
    : TableReaderInfo() {
    *this = ::std::move(from);
  }

  inline TableReaderInfo& operator=(const TableReaderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableReaderInfo& operator=(TableReaderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableReaderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableReaderInfo* internal_default_instance() {
    return reinterpret_cast<const TableReaderInfo*>(
               &_TableReaderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TableReaderInfo& a, TableReaderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TableReaderInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableReaderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableReaderInfo* New() const final {
    return new TableReaderInfo();
  }

  TableReaderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableReaderInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableReaderInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableReaderInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableReaderInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.TableReaderInfo";
  }
  protected:
  explicit TableReaderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TableReaderInfo_RouterType RouterType;
  static constexpr RouterType HASH =
    TableReaderInfo_RouterType_HASH;
  static constexpr RouterType AVERAGE =
    TableReaderInfo_RouterType_AVERAGE;
  static constexpr RouterType NATIVE =
    TableReaderInfo_RouterType_NATIVE;
  static constexpr RouterType BALANCE =
    TableReaderInfo_RouterType_BALANCE;
  static constexpr RouterType FLOWSMALL =
    TableReaderInfo_RouterType_FLOWSMALL;
  static constexpr RouterType FLOWBIG =
    TableReaderInfo_RouterType_FLOWBIG;
  static constexpr RouterType LDSKETCH =
    TableReaderInfo_RouterType_LDSKETCH;
  static inline bool RouterType_IsValid(int value) {
    return TableReaderInfo_RouterType_IsValid(value);
  }
  static constexpr RouterType RouterType_MIN =
    TableReaderInfo_RouterType_RouterType_MIN;
  static constexpr RouterType RouterType_MAX =
    TableReaderInfo_RouterType_RouterType_MAX;
  static constexpr int RouterType_ARRAYSIZE =
    TableReaderInfo_RouterType_RouterType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RouterType_descriptor() {
    return TableReaderInfo_RouterType_descriptor();
  }
  template<typename T>
  static inline const std::string& RouterType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RouterType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RouterType_Name.");
    return TableReaderInfo_RouterType_Name(enum_t_value);
  }
  static inline bool RouterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RouterType* value) {
    return TableReaderInfo_RouterType_Parse(name, value);
  }

  typedef TableReaderInfo_TableReaderType TableReaderType;
  static constexpr TableReaderType SMALL =
    TableReaderInfo_TableReaderType_SMALL;
  static constexpr TableReaderType BIG =
    TableReaderInfo_TableReaderType_BIG;
  static inline bool TableReaderType_IsValid(int value) {
    return TableReaderInfo_TableReaderType_IsValid(value);
  }
  static constexpr TableReaderType TableReaderType_MIN =
    TableReaderInfo_TableReaderType_TableReaderType_MIN;
  static constexpr TableReaderType TableReaderType_MAX =
    TableReaderInfo_TableReaderType_TableReaderType_MAX;
  static constexpr int TableReaderType_ARRAYSIZE =
    TableReaderInfo_TableReaderType_TableReaderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TableReaderType_descriptor() {
    return TableReaderInfo_TableReaderType_descriptor();
  }
  template<typename T>
  static inline const std::string& TableReaderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TableReaderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TableReaderType_Name.");
    return TableReaderInfo_TableReaderType_Name(enum_t_value);
  }
  static inline bool TableReaderType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TableReaderType* value) {
    return TableReaderInfo_TableReaderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOutputInfosFieldNumber = 5,
    kFileNameFieldNumber = 3,
    kIdFieldNumber = 1,
    kTrTypeFieldNumber = 2,
    kRouterTypeFieldNumber = 4,
  };
  // repeated .stream.StreamInfo output_infos = 5;
  int output_infos_size() const;
  private:
  int _internal_output_infos_size() const;
  public:
  void clear_output_infos();
  ::stream::StreamInfo* mutable_output_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
      mutable_output_infos();
  private:
  const ::stream::StreamInfo& _internal_output_infos(int index) const;
  ::stream::StreamInfo* _internal_add_output_infos();
  public:
  const ::stream::StreamInfo& output_infos(int index) const;
  ::stream::StreamInfo* add_output_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
      output_infos() const;

  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .stream.TableReaderInfo.TableReaderType tr_type = 2;
  void clear_tr_type();
  ::stream::TableReaderInfo_TableReaderType tr_type() const;
  void set_tr_type(::stream::TableReaderInfo_TableReaderType value);
  private:
  ::stream::TableReaderInfo_TableReaderType _internal_tr_type() const;
  void _internal_set_tr_type(::stream::TableReaderInfo_TableReaderType value);
  public:

  // .stream.TableReaderInfo.RouterType router_type = 4;
  void clear_router_type();
  ::stream::TableReaderInfo_RouterType router_type() const;
  void set_router_type(::stream::TableReaderInfo_RouterType value);
  private:
  ::stream::TableReaderInfo_RouterType _internal_router_type() const;
  void _internal_set_router_type(::stream::TableReaderInfo_RouterType value);
  public:

  // @@protoc_insertion_point(class_scope:stream.TableReaderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo > output_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int tr_type_;
  int router_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class HashJoinerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.HashJoinerInfo) */ {
 public:
  inline HashJoinerInfo() : HashJoinerInfo(nullptr) {}
  ~HashJoinerInfo() override;
  explicit constexpr HashJoinerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashJoinerInfo(const HashJoinerInfo& from);
  HashJoinerInfo(HashJoinerInfo&& from) noexcept
    : HashJoinerInfo() {
    *this = ::std::move(from);
  }

  inline HashJoinerInfo& operator=(const HashJoinerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashJoinerInfo& operator=(HashJoinerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashJoinerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashJoinerInfo* internal_default_instance() {
    return reinterpret_cast<const HashJoinerInfo*>(
               &_HashJoinerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HashJoinerInfo& a, HashJoinerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HashJoinerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashJoinerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HashJoinerInfo* New() const final {
    return new HashJoinerInfo();
  }

  HashJoinerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HashJoinerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HashJoinerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HashJoinerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashJoinerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.HashJoinerInfo";
  }
  protected:
  explicit HashJoinerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HashJoinerInfo_HJType HJType;
  static constexpr HJType BASE =
    HashJoinerInfo_HJType_BASE;
  static constexpr HJType PNR =
    HashJoinerInfo_HJType_PNR;
  static constexpr HJType PRPD =
    HashJoinerInfo_HJType_PRPD;
  static constexpr HJType BNR =
    HashJoinerInfo_HJType_BNR;
  static constexpr HJType FLOWJOIN =
    HashJoinerInfo_HJType_FLOWJOIN;
  static inline bool HJType_IsValid(int value) {
    return HashJoinerInfo_HJType_IsValid(value);
  }
  static constexpr HJType HJType_MIN =
    HashJoinerInfo_HJType_HJType_MIN;
  static constexpr HJType HJType_MAX =
    HashJoinerInfo_HJType_HJType_MAX;
  static constexpr int HJType_ARRAYSIZE =
    HashJoinerInfo_HJType_HJType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HJType_descriptor() {
    return HashJoinerInfo_HJType_descriptor();
  }
  template<typename T>
  static inline const std::string& HJType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HJType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HJType_Name.");
    return HashJoinerInfo_HJType_Name(enum_t_value);
  }
  static inline bool HJType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HJType* value) {
    return HashJoinerInfo_HJType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBigInfosFieldNumber = 2,
    kSmallInfosFieldNumber = 3,
    kBdInfosFieldNumber = 4,
    kOutputInfosFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // repeated .stream.StreamInfo big_infos = 2;
  int big_infos_size() const;
  private:
  int _internal_big_infos_size() const;
  public:
  void clear_big_infos();
  ::stream::StreamInfo* mutable_big_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
      mutable_big_infos();
  private:
  const ::stream::StreamInfo& _internal_big_infos(int index) const;
  ::stream::StreamInfo* _internal_add_big_infos();
  public:
  const ::stream::StreamInfo& big_infos(int index) const;
  ::stream::StreamInfo* add_big_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
      big_infos() const;

  // repeated .stream.StreamInfo small_infos = 3;
  int small_infos_size() const;
  private:
  int _internal_small_infos_size() const;
  public:
  void clear_small_infos();
  ::stream::StreamInfo* mutable_small_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
      mutable_small_infos();
  private:
  const ::stream::StreamInfo& _internal_small_infos(int index) const;
  ::stream::StreamInfo* _internal_add_small_infos();
  public:
  const ::stream::StreamInfo& small_infos(int index) const;
  ::stream::StreamInfo* add_small_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
      small_infos() const;

  // repeated .stream.StreamInfo bd_infos = 4;
  int bd_infos_size() const;
  private:
  int _internal_bd_infos_size() const;
  public:
  void clear_bd_infos();
  ::stream::StreamInfo* mutable_bd_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
      mutable_bd_infos();
  private:
  const ::stream::StreamInfo& _internal_bd_infos(int index) const;
  ::stream::StreamInfo* _internal_add_bd_infos();
  public:
  const ::stream::StreamInfo& bd_infos(int index) const;
  ::stream::StreamInfo* add_bd_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
      bd_infos() const;

  // repeated .stream.StreamInfo output_infos = 5;
  int output_infos_size() const;
  private:
  int _internal_output_infos_size() const;
  public:
  void clear_output_infos();
  ::stream::StreamInfo* mutable_output_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
      mutable_output_infos();
  private:
  const ::stream::StreamInfo& _internal_output_infos(int index) const;
  ::stream::StreamInfo* _internal_add_output_infos();
  public:
  const ::stream::StreamInfo& output_infos(int index) const;
  ::stream::StreamInfo* add_output_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
      output_infos() const;

  // .stream.HashJoinerInfo.HJType type = 1;
  void clear_type();
  ::stream::HashJoinerInfo_HJType type() const;
  void set_type(::stream::HashJoinerInfo_HJType value);
  private:
  ::stream::HashJoinerInfo_HJType _internal_type() const;
  void _internal_set_type(::stream::HashJoinerInfo_HJType value);
  public:

  // @@protoc_insertion_point(class_scope:stream.HashJoinerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo > big_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo > small_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo > bd_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo > output_infos_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class SFRInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.SFRInfo) */ {
 public:
  inline SFRInfo() : SFRInfo(nullptr) {}
  ~SFRInfo() override;
  explicit constexpr SFRInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SFRInfo(const SFRInfo& from);
  SFRInfo(SFRInfo&& from) noexcept
    : SFRInfo() {
    *this = ::std::move(from);
  }

  inline SFRInfo& operator=(const SFRInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFRInfo& operator=(SFRInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFRInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SFRInfo* internal_default_instance() {
    return reinterpret_cast<const SFRInfo*>(
               &_SFRInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SFRInfo& a, SFRInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SFRInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFRInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SFRInfo* New() const final {
    return new SFRInfo();
  }

  SFRInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SFRInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SFRInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SFRInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFRInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.SFRInfo";
  }
  protected:
  explicit SFRInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNFieldNumber = 1,
    kRowsFieldNumber = 2,
    kColsFieldNumber = 3,
  };
  // int32 n = 1;
  void clear_n();
  ::PROTOBUF_NAMESPACE_ID::int32 n() const;
  void set_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_n() const;
  void _internal_set_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rows = 2;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cols = 3;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:stream.SFRInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 n_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class ProcessorsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:stream.ProcessorsInfo) */ {
 public:
  inline ProcessorsInfo() : ProcessorsInfo(nullptr) {}
  ~ProcessorsInfo() override;
  explicit constexpr ProcessorsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessorsInfo(const ProcessorsInfo& from);
  ProcessorsInfo(ProcessorsInfo&& from) noexcept
    : ProcessorsInfo() {
    *this = ::std::move(from);
  }

  inline ProcessorsInfo& operator=(const ProcessorsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorsInfo& operator=(ProcessorsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessorsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessorsInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessorsInfo*>(
               &_ProcessorsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProcessorsInfo& a, ProcessorsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorsInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorsInfo* New() const final {
    return new ProcessorsInfo();
  }

  ProcessorsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessorsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcessorsInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorsInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "stream.ProcessorsInfo";
  }
  protected:
  explicit ProcessorsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablereaderInfosFieldNumber = 2,
    kHashjoinerInfosFieldNumber = 3,
    kSfrInfoFieldNumber = 1,
  };
  // repeated .stream.TableReaderInfo tablereader_infos = 2;
  int tablereader_infos_size() const;
  private:
  int _internal_tablereader_infos_size() const;
  public:
  void clear_tablereader_infos();
  ::stream::TableReaderInfo* mutable_tablereader_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::TableReaderInfo >*
      mutable_tablereader_infos();
  private:
  const ::stream::TableReaderInfo& _internal_tablereader_infos(int index) const;
  ::stream::TableReaderInfo* _internal_add_tablereader_infos();
  public:
  const ::stream::TableReaderInfo& tablereader_infos(int index) const;
  ::stream::TableReaderInfo* add_tablereader_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::TableReaderInfo >&
      tablereader_infos() const;

  // repeated .stream.HashJoinerInfo hashjoiner_infos = 3;
  int hashjoiner_infos_size() const;
  private:
  int _internal_hashjoiner_infos_size() const;
  public:
  void clear_hashjoiner_infos();
  ::stream::HashJoinerInfo* mutable_hashjoiner_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::HashJoinerInfo >*
      mutable_hashjoiner_infos();
  private:
  const ::stream::HashJoinerInfo& _internal_hashjoiner_infos(int index) const;
  ::stream::HashJoinerInfo* _internal_add_hashjoiner_infos();
  public:
  const ::stream::HashJoinerInfo& hashjoiner_infos(int index) const;
  ::stream::HashJoinerInfo* add_hashjoiner_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::HashJoinerInfo >&
      hashjoiner_infos() const;

  // .stream.SFRInfo sfr_info = 1;
  bool has_sfr_info() const;
  private:
  bool _internal_has_sfr_info() const;
  public:
  void clear_sfr_info();
  const ::stream::SFRInfo& sfr_info() const;
  PROTOBUF_MUST_USE_RESULT ::stream::SFRInfo* release_sfr_info();
  ::stream::SFRInfo* mutable_sfr_info();
  void set_allocated_sfr_info(::stream::SFRInfo* sfr_info);
  private:
  const ::stream::SFRInfo& _internal_sfr_info() const;
  ::stream::SFRInfo* _internal_mutable_sfr_info();
  public:
  void unsafe_arena_set_allocated_sfr_info(
      ::stream::SFRInfo* sfr_info);
  ::stream::SFRInfo* unsafe_arena_release_sfr_info();

  // @@protoc_insertion_point(class_scope:stream.ProcessorsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::TableReaderInfo > tablereader_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::HashJoinerInfo > hashjoiner_infos_;
  ::stream::SFRInfo* sfr_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_stream_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StatisticMsg

// int64 network_phase1 = 1;
inline void StatisticMsg::clear_network_phase1() {
  network_phase1_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::_internal_network_phase1() const {
  return network_phase1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::network_phase1() const {
  // @@protoc_insertion_point(field_get:stream.StatisticMsg.network_phase1)
  return _internal_network_phase1();
}
inline void StatisticMsg::_internal_set_network_phase1(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  network_phase1_ = value;
}
inline void StatisticMsg::set_network_phase1(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_network_phase1(value);
  // @@protoc_insertion_point(field_set:stream.StatisticMsg.network_phase1)
}

// int64 network_phase2 = 2;
inline void StatisticMsg::clear_network_phase2() {
  network_phase2_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::_internal_network_phase2() const {
  return network_phase2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::network_phase2() const {
  // @@protoc_insertion_point(field_get:stream.StatisticMsg.network_phase2)
  return _internal_network_phase2();
}
inline void StatisticMsg::_internal_set_network_phase2(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  network_phase2_ = value;
}
inline void StatisticMsg::set_network_phase2(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_network_phase2(value);
  // @@protoc_insertion_point(field_set:stream.StatisticMsg.network_phase2)
}

// int64 result_counts = 3;
inline void StatisticMsg::clear_result_counts() {
  result_counts_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::_internal_result_counts() const {
  return result_counts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StatisticMsg::result_counts() const {
  // @@protoc_insertion_point(field_get:stream.StatisticMsg.result_counts)
  return _internal_result_counts();
}
inline void StatisticMsg::_internal_set_result_counts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  result_counts_ = value;
}
inline void StatisticMsg::set_result_counts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_result_counts(value);
  // @@protoc_insertion_point(field_set:stream.StatisticMsg.result_counts)
}

// repeated .stream.Tuple small_skewkeys = 4;
inline int StatisticMsg::_internal_small_skewkeys_size() const {
  return small_skewkeys_.size();
}
inline int StatisticMsg::small_skewkeys_size() const {
  return _internal_small_skewkeys_size();
}
inline void StatisticMsg::clear_small_skewkeys() {
  small_skewkeys_.Clear();
}
inline ::stream::Tuple* StatisticMsg::mutable_small_skewkeys(int index) {
  // @@protoc_insertion_point(field_mutable:stream.StatisticMsg.small_skewkeys)
  return small_skewkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
StatisticMsg::mutable_small_skewkeys() {
  // @@protoc_insertion_point(field_mutable_list:stream.StatisticMsg.small_skewkeys)
  return &small_skewkeys_;
}
inline const ::stream::Tuple& StatisticMsg::_internal_small_skewkeys(int index) const {
  return small_skewkeys_.Get(index);
}
inline const ::stream::Tuple& StatisticMsg::small_skewkeys(int index) const {
  // @@protoc_insertion_point(field_get:stream.StatisticMsg.small_skewkeys)
  return _internal_small_skewkeys(index);
}
inline ::stream::Tuple* StatisticMsg::_internal_add_small_skewkeys() {
  return small_skewkeys_.Add();
}
inline ::stream::Tuple* StatisticMsg::add_small_skewkeys() {
  ::stream::Tuple* _add = _internal_add_small_skewkeys();
  // @@protoc_insertion_point(field_add:stream.StatisticMsg.small_skewkeys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
StatisticMsg::small_skewkeys() const {
  // @@protoc_insertion_point(field_list:stream.StatisticMsg.small_skewkeys)
  return small_skewkeys_;
}

// repeated .stream.Tuple big_skewkeys = 5;
inline int StatisticMsg::_internal_big_skewkeys_size() const {
  return big_skewkeys_.size();
}
inline int StatisticMsg::big_skewkeys_size() const {
  return _internal_big_skewkeys_size();
}
inline void StatisticMsg::clear_big_skewkeys() {
  big_skewkeys_.Clear();
}
inline ::stream::Tuple* StatisticMsg::mutable_big_skewkeys(int index) {
  // @@protoc_insertion_point(field_mutable:stream.StatisticMsg.big_skewkeys)
  return big_skewkeys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
StatisticMsg::mutable_big_skewkeys() {
  // @@protoc_insertion_point(field_mutable_list:stream.StatisticMsg.big_skewkeys)
  return &big_skewkeys_;
}
inline const ::stream::Tuple& StatisticMsg::_internal_big_skewkeys(int index) const {
  return big_skewkeys_.Get(index);
}
inline const ::stream::Tuple& StatisticMsg::big_skewkeys(int index) const {
  // @@protoc_insertion_point(field_get:stream.StatisticMsg.big_skewkeys)
  return _internal_big_skewkeys(index);
}
inline ::stream::Tuple* StatisticMsg::_internal_add_big_skewkeys() {
  return big_skewkeys_.Add();
}
inline ::stream::Tuple* StatisticMsg::add_big_skewkeys() {
  ::stream::Tuple* _add = _internal_add_big_skewkeys();
  // @@protoc_insertion_point(field_add:stream.StatisticMsg.big_skewkeys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
StatisticMsg::big_skewkeys() const {
  // @@protoc_insertion_point(field_list:stream.StatisticMsg.big_skewkeys)
  return big_skewkeys_;
}

// -------------------------------------------------------------------

// StreamSummary

// int64 count = 1;
inline void StreamSummary::clear_count() {
  count_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StreamSummary::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StreamSummary::count() const {
  // @@protoc_insertion_point(field_get:stream.StreamSummary.count)
  return _internal_count();
}
inline void StreamSummary::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  count_ = value;
}
inline void StreamSummary::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:stream.StreamSummary.count)
}

// -------------------------------------------------------------------

// Tuple

// string key = 1;
inline void Tuple::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Tuple::key() const {
  // @@protoc_insertion_point(field_get:stream.Tuple.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tuple::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stream.Tuple.key)
}
inline std::string* Tuple::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:stream.Tuple.key)
  return _s;
}
inline const std::string& Tuple::_internal_key() const {
  return key_.Get();
}
inline void Tuple::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Tuple::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Tuple::release_key() {
  // @@protoc_insertion_point(field_release:stream.Tuple.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Tuple::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:stream.Tuple.key)
}

// string value = 2;
inline void Tuple::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Tuple::value() const {
  // @@protoc_insertion_point(field_get:stream.Tuple.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tuple::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stream.Tuple.value)
}
inline std::string* Tuple::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:stream.Tuple.value)
  return _s;
}
inline const std::string& Tuple::_internal_value() const {
  return value_.Get();
}
inline void Tuple::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Tuple::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Tuple::release_value() {
  // @@protoc_insertion_point(field_release:stream.Tuple.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Tuple::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:stream.Tuple.value)
}

// -------------------------------------------------------------------

// BatchTuple

// bool empty = 1;
inline void BatchTuple::clear_empty() {
  empty_ = false;
}
inline bool BatchTuple::_internal_empty() const {
  return empty_;
}
inline bool BatchTuple::empty() const {
  // @@protoc_insertion_point(field_get:stream.BatchTuple.empty)
  return _internal_empty();
}
inline void BatchTuple::_internal_set_empty(bool value) {
  
  empty_ = value;
}
inline void BatchTuple::set_empty(bool value) {
  _internal_set_empty(value);
  // @@protoc_insertion_point(field_set:stream.BatchTuple.empty)
}

// repeated .stream.Tuple tuples = 3;
inline int BatchTuple::_internal_tuples_size() const {
  return tuples_.size();
}
inline int BatchTuple::tuples_size() const {
  return _internal_tuples_size();
}
inline void BatchTuple::clear_tuples() {
  tuples_.Clear();
}
inline ::stream::Tuple* BatchTuple::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:stream.BatchTuple.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >*
BatchTuple::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:stream.BatchTuple.tuples)
  return &tuples_;
}
inline const ::stream::Tuple& BatchTuple::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::stream::Tuple& BatchTuple::tuples(int index) const {
  // @@protoc_insertion_point(field_get:stream.BatchTuple.tuples)
  return _internal_tuples(index);
}
inline ::stream::Tuple* BatchTuple::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::stream::Tuple* BatchTuple::add_tuples() {
  ::stream::Tuple* _add = _internal_add_tuples();
  // @@protoc_insertion_point(field_add:stream.BatchTuple.tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::Tuple >&
BatchTuple::tuples() const {
  // @@protoc_insertion_point(field_list:stream.BatchTuple.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// SMessage

// int32 stream_id = 1;
inline void SMessage::clear_stream_id() {
  stream_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMessage::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SMessage::stream_id() const {
  // @@protoc_insertion_point(field_get:stream.SMessage.stream_id)
  return _internal_stream_id();
}
inline void SMessage::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stream_id_ = value;
}
inline void SMessage::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:stream.SMessage.stream_id)
}

// repeated string skew_keys = 2;
inline int SMessage::_internal_skew_keys_size() const {
  return skew_keys_.size();
}
inline int SMessage::skew_keys_size() const {
  return _internal_skew_keys_size();
}
inline void SMessage::clear_skew_keys() {
  skew_keys_.Clear();
}
inline std::string* SMessage::add_skew_keys() {
  std::string* _s = _internal_add_skew_keys();
  // @@protoc_insertion_point(field_add_mutable:stream.SMessage.skew_keys)
  return _s;
}
inline const std::string& SMessage::_internal_skew_keys(int index) const {
  return skew_keys_.Get(index);
}
inline const std::string& SMessage::skew_keys(int index) const {
  // @@protoc_insertion_point(field_get:stream.SMessage.skew_keys)
  return _internal_skew_keys(index);
}
inline std::string* SMessage::mutable_skew_keys(int index) {
  // @@protoc_insertion_point(field_mutable:stream.SMessage.skew_keys)
  return skew_keys_.Mutable(index);
}
inline void SMessage::set_skew_keys(int index, const std::string& value) {
  skew_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:stream.SMessage.skew_keys)
}
inline void SMessage::set_skew_keys(int index, std::string&& value) {
  skew_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:stream.SMessage.skew_keys)
}
inline void SMessage::set_skew_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  skew_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stream.SMessage.skew_keys)
}
inline void SMessage::set_skew_keys(int index, const char* value, size_t size) {
  skew_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream.SMessage.skew_keys)
}
inline std::string* SMessage::_internal_add_skew_keys() {
  return skew_keys_.Add();
}
inline void SMessage::add_skew_keys(const std::string& value) {
  skew_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stream.SMessage.skew_keys)
}
inline void SMessage::add_skew_keys(std::string&& value) {
  skew_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:stream.SMessage.skew_keys)
}
inline void SMessage::add_skew_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  skew_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stream.SMessage.skew_keys)
}
inline void SMessage::add_skew_keys(const char* value, size_t size) {
  skew_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stream.SMessage.skew_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SMessage::skew_keys() const {
  // @@protoc_insertion_point(field_list:stream.SMessage.skew_keys)
  return skew_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SMessage::mutable_skew_keys() {
  // @@protoc_insertion_point(field_mutable_list:stream.SMessage.skew_keys)
  return &skew_keys_;
}

// .stream.BatchTuple batch_tuples = 3;
inline bool SMessage::_internal_has_batch_tuples() const {
  return this != internal_default_instance() && batch_tuples_ != nullptr;
}
inline bool SMessage::has_batch_tuples() const {
  return _internal_has_batch_tuples();
}
inline void SMessage::clear_batch_tuples() {
  if (GetArenaForAllocation() == nullptr && batch_tuples_ != nullptr) {
    delete batch_tuples_;
  }
  batch_tuples_ = nullptr;
}
inline const ::stream::BatchTuple& SMessage::_internal_batch_tuples() const {
  const ::stream::BatchTuple* p = batch_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::stream::BatchTuple&>(
      ::stream::_BatchTuple_default_instance_);
}
inline const ::stream::BatchTuple& SMessage::batch_tuples() const {
  // @@protoc_insertion_point(field_get:stream.SMessage.batch_tuples)
  return _internal_batch_tuples();
}
inline void SMessage::unsafe_arena_set_allocated_batch_tuples(
    ::stream::BatchTuple* batch_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_tuples_);
  }
  batch_tuples_ = batch_tuples;
  if (batch_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stream.SMessage.batch_tuples)
}
inline ::stream::BatchTuple* SMessage::release_batch_tuples() {
  
  ::stream::BatchTuple* temp = batch_tuples_;
  batch_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::stream::BatchTuple* SMessage::unsafe_arena_release_batch_tuples() {
  // @@protoc_insertion_point(field_release:stream.SMessage.batch_tuples)
  
  ::stream::BatchTuple* temp = batch_tuples_;
  batch_tuples_ = nullptr;
  return temp;
}
inline ::stream::BatchTuple* SMessage::_internal_mutable_batch_tuples() {
  
  if (batch_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::stream::BatchTuple>(GetArenaForAllocation());
    batch_tuples_ = p;
  }
  return batch_tuples_;
}
inline ::stream::BatchTuple* SMessage::mutable_batch_tuples() {
  ::stream::BatchTuple* _msg = _internal_mutable_batch_tuples();
  // @@protoc_insertion_point(field_mutable:stream.SMessage.batch_tuples)
  return _msg;
}
inline void SMessage::set_allocated_batch_tuples(::stream::BatchTuple* batch_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete batch_tuples_;
  }
  if (batch_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::stream::BatchTuple>::GetOwningArena(batch_tuples);
    if (message_arena != submessage_arena) {
      batch_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_tuples, submessage_arena);
    }
    
  } else {
    
  }
  batch_tuples_ = batch_tuples;
  // @@protoc_insertion_point(field_set_allocated:stream.SMessage.batch_tuples)
}

// -------------------------------------------------------------------

// BDMessage

// int32 stream_id = 1;
inline void BDMessage::clear_stream_id() {
  stream_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BDMessage::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BDMessage::stream_id() const {
  // @@protoc_insertion_point(field_get:stream.BDMessage.stream_id)
  return _internal_stream_id();
}
inline void BDMessage::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stream_id_ = value;
}
inline void BDMessage::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:stream.BDMessage.stream_id)
}

// repeated string need_keys = 2;
inline int BDMessage::_internal_need_keys_size() const {
  return need_keys_.size();
}
inline int BDMessage::need_keys_size() const {
  return _internal_need_keys_size();
}
inline void BDMessage::clear_need_keys() {
  need_keys_.Clear();
}
inline std::string* BDMessage::add_need_keys() {
  std::string* _s = _internal_add_need_keys();
  // @@protoc_insertion_point(field_add_mutable:stream.BDMessage.need_keys)
  return _s;
}
inline const std::string& BDMessage::_internal_need_keys(int index) const {
  return need_keys_.Get(index);
}
inline const std::string& BDMessage::need_keys(int index) const {
  // @@protoc_insertion_point(field_get:stream.BDMessage.need_keys)
  return _internal_need_keys(index);
}
inline std::string* BDMessage::mutable_need_keys(int index) {
  // @@protoc_insertion_point(field_mutable:stream.BDMessage.need_keys)
  return need_keys_.Mutable(index);
}
inline void BDMessage::set_need_keys(int index, const std::string& value) {
  need_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:stream.BDMessage.need_keys)
}
inline void BDMessage::set_need_keys(int index, std::string&& value) {
  need_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:stream.BDMessage.need_keys)
}
inline void BDMessage::set_need_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stream.BDMessage.need_keys)
}
inline void BDMessage::set_need_keys(int index, const char* value, size_t size) {
  need_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream.BDMessage.need_keys)
}
inline std::string* BDMessage::_internal_add_need_keys() {
  return need_keys_.Add();
}
inline void BDMessage::add_need_keys(const std::string& value) {
  need_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stream.BDMessage.need_keys)
}
inline void BDMessage::add_need_keys(std::string&& value) {
  need_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:stream.BDMessage.need_keys)
}
inline void BDMessage::add_need_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stream.BDMessage.need_keys)
}
inline void BDMessage::add_need_keys(const char* value, size_t size) {
  need_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stream.BDMessage.need_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BDMessage::need_keys() const {
  // @@protoc_insertion_point(field_list:stream.BDMessage.need_keys)
  return need_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BDMessage::mutable_need_keys() {
  // @@protoc_insertion_point(field_mutable_list:stream.BDMessage.need_keys)
  return &need_keys_;
}

// repeated string done_keys = 3;
inline int BDMessage::_internal_done_keys_size() const {
  return done_keys_.size();
}
inline int BDMessage::done_keys_size() const {
  return _internal_done_keys_size();
}
inline void BDMessage::clear_done_keys() {
  done_keys_.Clear();
}
inline std::string* BDMessage::add_done_keys() {
  std::string* _s = _internal_add_done_keys();
  // @@protoc_insertion_point(field_add_mutable:stream.BDMessage.done_keys)
  return _s;
}
inline const std::string& BDMessage::_internal_done_keys(int index) const {
  return done_keys_.Get(index);
}
inline const std::string& BDMessage::done_keys(int index) const {
  // @@protoc_insertion_point(field_get:stream.BDMessage.done_keys)
  return _internal_done_keys(index);
}
inline std::string* BDMessage::mutable_done_keys(int index) {
  // @@protoc_insertion_point(field_mutable:stream.BDMessage.done_keys)
  return done_keys_.Mutable(index);
}
inline void BDMessage::set_done_keys(int index, const std::string& value) {
  done_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:stream.BDMessage.done_keys)
}
inline void BDMessage::set_done_keys(int index, std::string&& value) {
  done_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:stream.BDMessage.done_keys)
}
inline void BDMessage::set_done_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  done_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:stream.BDMessage.done_keys)
}
inline void BDMessage::set_done_keys(int index, const char* value, size_t size) {
  done_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream.BDMessage.done_keys)
}
inline std::string* BDMessage::_internal_add_done_keys() {
  return done_keys_.Add();
}
inline void BDMessage::add_done_keys(const std::string& value) {
  done_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:stream.BDMessage.done_keys)
}
inline void BDMessage::add_done_keys(std::string&& value) {
  done_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:stream.BDMessage.done_keys)
}
inline void BDMessage::add_done_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  done_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:stream.BDMessage.done_keys)
}
inline void BDMessage::add_done_keys(const char* value, size_t size) {
  done_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:stream.BDMessage.done_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BDMessage::done_keys() const {
  // @@protoc_insertion_point(field_list:stream.BDMessage.done_keys)
  return done_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BDMessage::mutable_done_keys() {
  // @@protoc_insertion_point(field_mutable_list:stream.BDMessage.done_keys)
  return &done_keys_;
}

// .stream.BatchTuple batch_tuples = 4;
inline bool BDMessage::_internal_has_batch_tuples() const {
  return this != internal_default_instance() && batch_tuples_ != nullptr;
}
inline bool BDMessage::has_batch_tuples() const {
  return _internal_has_batch_tuples();
}
inline void BDMessage::clear_batch_tuples() {
  if (GetArenaForAllocation() == nullptr && batch_tuples_ != nullptr) {
    delete batch_tuples_;
  }
  batch_tuples_ = nullptr;
}
inline const ::stream::BatchTuple& BDMessage::_internal_batch_tuples() const {
  const ::stream::BatchTuple* p = batch_tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::stream::BatchTuple&>(
      ::stream::_BatchTuple_default_instance_);
}
inline const ::stream::BatchTuple& BDMessage::batch_tuples() const {
  // @@protoc_insertion_point(field_get:stream.BDMessage.batch_tuples)
  return _internal_batch_tuples();
}
inline void BDMessage::unsafe_arena_set_allocated_batch_tuples(
    ::stream::BatchTuple* batch_tuples) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_tuples_);
  }
  batch_tuples_ = batch_tuples;
  if (batch_tuples) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stream.BDMessage.batch_tuples)
}
inline ::stream::BatchTuple* BDMessage::release_batch_tuples() {
  
  ::stream::BatchTuple* temp = batch_tuples_;
  batch_tuples_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::stream::BatchTuple* BDMessage::unsafe_arena_release_batch_tuples() {
  // @@protoc_insertion_point(field_release:stream.BDMessage.batch_tuples)
  
  ::stream::BatchTuple* temp = batch_tuples_;
  batch_tuples_ = nullptr;
  return temp;
}
inline ::stream::BatchTuple* BDMessage::_internal_mutable_batch_tuples() {
  
  if (batch_tuples_ == nullptr) {
    auto* p = CreateMaybeMessage<::stream::BatchTuple>(GetArenaForAllocation());
    batch_tuples_ = p;
  }
  return batch_tuples_;
}
inline ::stream::BatchTuple* BDMessage::mutable_batch_tuples() {
  ::stream::BatchTuple* _msg = _internal_mutable_batch_tuples();
  // @@protoc_insertion_point(field_mutable:stream.BDMessage.batch_tuples)
  return _msg;
}
inline void BDMessage::set_allocated_batch_tuples(::stream::BatchTuple* batch_tuples) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete batch_tuples_;
  }
  if (batch_tuples) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::stream::BatchTuple>::GetOwningArena(batch_tuples);
    if (message_arena != submessage_arena) {
      batch_tuples = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_tuples, submessage_arena);
    }
    
  } else {
    
  }
  batch_tuples_ = batch_tuples;
  // @@protoc_insertion_point(field_set_allocated:stream.BDMessage.batch_tuples)
}

// bool close = 5;
inline void BDMessage::clear_close() {
  close_ = false;
}
inline bool BDMessage::_internal_close() const {
  return close_;
}
inline bool BDMessage::close() const {
  // @@protoc_insertion_point(field_get:stream.BDMessage.close)
  return _internal_close();
}
inline void BDMessage::_internal_set_close(bool value) {
  
  close_ = value;
}
inline void BDMessage::set_close(bool value) {
  _internal_set_close(value);
  // @@protoc_insertion_point(field_set:stream.BDMessage.close)
}

// -------------------------------------------------------------------

// StreamInfo

// int32 stream_id = 1;
inline void StreamInfo::clear_stream_id() {
  stream_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamInfo::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StreamInfo::stream_id() const {
  // @@protoc_insertion_point(field_get:stream.StreamInfo.stream_id)
  return _internal_stream_id();
}
inline void StreamInfo::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  stream_id_ = value;
}
inline void StreamInfo::set_stream_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:stream.StreamInfo.stream_id)
}

// .stream.StreamInfo.StreamType type = 2;
inline void StreamInfo::clear_type() {
  type_ = 0;
}
inline ::stream::StreamInfo_StreamType StreamInfo::_internal_type() const {
  return static_cast< ::stream::StreamInfo_StreamType >(type_);
}
inline ::stream::StreamInfo_StreamType StreamInfo::type() const {
  // @@protoc_insertion_point(field_get:stream.StreamInfo.type)
  return _internal_type();
}
inline void StreamInfo::_internal_set_type(::stream::StreamInfo_StreamType value) {
  
  type_ = value;
}
inline void StreamInfo::set_type(::stream::StreamInfo_StreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:stream.StreamInfo.type)
}

// string server_address = 3;
inline void StreamInfo::clear_server_address() {
  server_address_.ClearToEmpty();
}
inline const std::string& StreamInfo::server_address() const {
  // @@protoc_insertion_point(field_get:stream.StreamInfo.server_address)
  return _internal_server_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_server_address(ArgT0&& arg0, ArgT... args) {
 
 server_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stream.StreamInfo.server_address)
}
inline std::string* StreamInfo::mutable_server_address() {
  std::string* _s = _internal_mutable_server_address();
  // @@protoc_insertion_point(field_mutable:stream.StreamInfo.server_address)
  return _s;
}
inline const std::string& StreamInfo::_internal_server_address() const {
  return server_address_.Get();
}
inline void StreamInfo::_internal_set_server_address(const std::string& value) {
  
  server_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_server_address() {
  
  return server_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamInfo::release_server_address() {
  // @@protoc_insertion_point(field_release:stream.StreamInfo.server_address)
  return server_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamInfo::set_allocated_server_address(std::string* server_address) {
  if (server_address != nullptr) {
    
  } else {
    
  }
  server_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:stream.StreamInfo.server_address)
}

// -------------------------------------------------------------------

// TableReaderInfo

// int32 id = 1;
inline void TableReaderInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableReaderInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableReaderInfo::id() const {
  // @@protoc_insertion_point(field_get:stream.TableReaderInfo.id)
  return _internal_id();
}
inline void TableReaderInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void TableReaderInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:stream.TableReaderInfo.id)
}

// .stream.TableReaderInfo.TableReaderType tr_type = 2;
inline void TableReaderInfo::clear_tr_type() {
  tr_type_ = 0;
}
inline ::stream::TableReaderInfo_TableReaderType TableReaderInfo::_internal_tr_type() const {
  return static_cast< ::stream::TableReaderInfo_TableReaderType >(tr_type_);
}
inline ::stream::TableReaderInfo_TableReaderType TableReaderInfo::tr_type() const {
  // @@protoc_insertion_point(field_get:stream.TableReaderInfo.tr_type)
  return _internal_tr_type();
}
inline void TableReaderInfo::_internal_set_tr_type(::stream::TableReaderInfo_TableReaderType value) {
  
  tr_type_ = value;
}
inline void TableReaderInfo::set_tr_type(::stream::TableReaderInfo_TableReaderType value) {
  _internal_set_tr_type(value);
  // @@protoc_insertion_point(field_set:stream.TableReaderInfo.tr_type)
}

// string file_name = 3;
inline void TableReaderInfo::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& TableReaderInfo::file_name() const {
  // @@protoc_insertion_point(field_get:stream.TableReaderInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableReaderInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:stream.TableReaderInfo.file_name)
}
inline std::string* TableReaderInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:stream.TableReaderInfo.file_name)
  return _s;
}
inline const std::string& TableReaderInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void TableReaderInfo::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TableReaderInfo::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TableReaderInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:stream.TableReaderInfo.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TableReaderInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:stream.TableReaderInfo.file_name)
}

// .stream.TableReaderInfo.RouterType router_type = 4;
inline void TableReaderInfo::clear_router_type() {
  router_type_ = 0;
}
inline ::stream::TableReaderInfo_RouterType TableReaderInfo::_internal_router_type() const {
  return static_cast< ::stream::TableReaderInfo_RouterType >(router_type_);
}
inline ::stream::TableReaderInfo_RouterType TableReaderInfo::router_type() const {
  // @@protoc_insertion_point(field_get:stream.TableReaderInfo.router_type)
  return _internal_router_type();
}
inline void TableReaderInfo::_internal_set_router_type(::stream::TableReaderInfo_RouterType value) {
  
  router_type_ = value;
}
inline void TableReaderInfo::set_router_type(::stream::TableReaderInfo_RouterType value) {
  _internal_set_router_type(value);
  // @@protoc_insertion_point(field_set:stream.TableReaderInfo.router_type)
}

// repeated .stream.StreamInfo output_infos = 5;
inline int TableReaderInfo::_internal_output_infos_size() const {
  return output_infos_.size();
}
inline int TableReaderInfo::output_infos_size() const {
  return _internal_output_infos_size();
}
inline void TableReaderInfo::clear_output_infos() {
  output_infos_.Clear();
}
inline ::stream::StreamInfo* TableReaderInfo::mutable_output_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.TableReaderInfo.output_infos)
  return output_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
TableReaderInfo::mutable_output_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.TableReaderInfo.output_infos)
  return &output_infos_;
}
inline const ::stream::StreamInfo& TableReaderInfo::_internal_output_infos(int index) const {
  return output_infos_.Get(index);
}
inline const ::stream::StreamInfo& TableReaderInfo::output_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.TableReaderInfo.output_infos)
  return _internal_output_infos(index);
}
inline ::stream::StreamInfo* TableReaderInfo::_internal_add_output_infos() {
  return output_infos_.Add();
}
inline ::stream::StreamInfo* TableReaderInfo::add_output_infos() {
  ::stream::StreamInfo* _add = _internal_add_output_infos();
  // @@protoc_insertion_point(field_add:stream.TableReaderInfo.output_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
TableReaderInfo::output_infos() const {
  // @@protoc_insertion_point(field_list:stream.TableReaderInfo.output_infos)
  return output_infos_;
}

// -------------------------------------------------------------------

// HashJoinerInfo

// .stream.HashJoinerInfo.HJType type = 1;
inline void HashJoinerInfo::clear_type() {
  type_ = 0;
}
inline ::stream::HashJoinerInfo_HJType HashJoinerInfo::_internal_type() const {
  return static_cast< ::stream::HashJoinerInfo_HJType >(type_);
}
inline ::stream::HashJoinerInfo_HJType HashJoinerInfo::type() const {
  // @@protoc_insertion_point(field_get:stream.HashJoinerInfo.type)
  return _internal_type();
}
inline void HashJoinerInfo::_internal_set_type(::stream::HashJoinerInfo_HJType value) {
  
  type_ = value;
}
inline void HashJoinerInfo::set_type(::stream::HashJoinerInfo_HJType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:stream.HashJoinerInfo.type)
}

// repeated .stream.StreamInfo big_infos = 2;
inline int HashJoinerInfo::_internal_big_infos_size() const {
  return big_infos_.size();
}
inline int HashJoinerInfo::big_infos_size() const {
  return _internal_big_infos_size();
}
inline void HashJoinerInfo::clear_big_infos() {
  big_infos_.Clear();
}
inline ::stream::StreamInfo* HashJoinerInfo::mutable_big_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.HashJoinerInfo.big_infos)
  return big_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
HashJoinerInfo::mutable_big_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.HashJoinerInfo.big_infos)
  return &big_infos_;
}
inline const ::stream::StreamInfo& HashJoinerInfo::_internal_big_infos(int index) const {
  return big_infos_.Get(index);
}
inline const ::stream::StreamInfo& HashJoinerInfo::big_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.HashJoinerInfo.big_infos)
  return _internal_big_infos(index);
}
inline ::stream::StreamInfo* HashJoinerInfo::_internal_add_big_infos() {
  return big_infos_.Add();
}
inline ::stream::StreamInfo* HashJoinerInfo::add_big_infos() {
  ::stream::StreamInfo* _add = _internal_add_big_infos();
  // @@protoc_insertion_point(field_add:stream.HashJoinerInfo.big_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
HashJoinerInfo::big_infos() const {
  // @@protoc_insertion_point(field_list:stream.HashJoinerInfo.big_infos)
  return big_infos_;
}

// repeated .stream.StreamInfo small_infos = 3;
inline int HashJoinerInfo::_internal_small_infos_size() const {
  return small_infos_.size();
}
inline int HashJoinerInfo::small_infos_size() const {
  return _internal_small_infos_size();
}
inline void HashJoinerInfo::clear_small_infos() {
  small_infos_.Clear();
}
inline ::stream::StreamInfo* HashJoinerInfo::mutable_small_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.HashJoinerInfo.small_infos)
  return small_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
HashJoinerInfo::mutable_small_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.HashJoinerInfo.small_infos)
  return &small_infos_;
}
inline const ::stream::StreamInfo& HashJoinerInfo::_internal_small_infos(int index) const {
  return small_infos_.Get(index);
}
inline const ::stream::StreamInfo& HashJoinerInfo::small_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.HashJoinerInfo.small_infos)
  return _internal_small_infos(index);
}
inline ::stream::StreamInfo* HashJoinerInfo::_internal_add_small_infos() {
  return small_infos_.Add();
}
inline ::stream::StreamInfo* HashJoinerInfo::add_small_infos() {
  ::stream::StreamInfo* _add = _internal_add_small_infos();
  // @@protoc_insertion_point(field_add:stream.HashJoinerInfo.small_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
HashJoinerInfo::small_infos() const {
  // @@protoc_insertion_point(field_list:stream.HashJoinerInfo.small_infos)
  return small_infos_;
}

// repeated .stream.StreamInfo bd_infos = 4;
inline int HashJoinerInfo::_internal_bd_infos_size() const {
  return bd_infos_.size();
}
inline int HashJoinerInfo::bd_infos_size() const {
  return _internal_bd_infos_size();
}
inline void HashJoinerInfo::clear_bd_infos() {
  bd_infos_.Clear();
}
inline ::stream::StreamInfo* HashJoinerInfo::mutable_bd_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.HashJoinerInfo.bd_infos)
  return bd_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
HashJoinerInfo::mutable_bd_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.HashJoinerInfo.bd_infos)
  return &bd_infos_;
}
inline const ::stream::StreamInfo& HashJoinerInfo::_internal_bd_infos(int index) const {
  return bd_infos_.Get(index);
}
inline const ::stream::StreamInfo& HashJoinerInfo::bd_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.HashJoinerInfo.bd_infos)
  return _internal_bd_infos(index);
}
inline ::stream::StreamInfo* HashJoinerInfo::_internal_add_bd_infos() {
  return bd_infos_.Add();
}
inline ::stream::StreamInfo* HashJoinerInfo::add_bd_infos() {
  ::stream::StreamInfo* _add = _internal_add_bd_infos();
  // @@protoc_insertion_point(field_add:stream.HashJoinerInfo.bd_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
HashJoinerInfo::bd_infos() const {
  // @@protoc_insertion_point(field_list:stream.HashJoinerInfo.bd_infos)
  return bd_infos_;
}

// repeated .stream.StreamInfo output_infos = 5;
inline int HashJoinerInfo::_internal_output_infos_size() const {
  return output_infos_.size();
}
inline int HashJoinerInfo::output_infos_size() const {
  return _internal_output_infos_size();
}
inline void HashJoinerInfo::clear_output_infos() {
  output_infos_.Clear();
}
inline ::stream::StreamInfo* HashJoinerInfo::mutable_output_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.HashJoinerInfo.output_infos)
  return output_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >*
HashJoinerInfo::mutable_output_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.HashJoinerInfo.output_infos)
  return &output_infos_;
}
inline const ::stream::StreamInfo& HashJoinerInfo::_internal_output_infos(int index) const {
  return output_infos_.Get(index);
}
inline const ::stream::StreamInfo& HashJoinerInfo::output_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.HashJoinerInfo.output_infos)
  return _internal_output_infos(index);
}
inline ::stream::StreamInfo* HashJoinerInfo::_internal_add_output_infos() {
  return output_infos_.Add();
}
inline ::stream::StreamInfo* HashJoinerInfo::add_output_infos() {
  ::stream::StreamInfo* _add = _internal_add_output_infos();
  // @@protoc_insertion_point(field_add:stream.HashJoinerInfo.output_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::StreamInfo >&
HashJoinerInfo::output_infos() const {
  // @@protoc_insertion_point(field_list:stream.HashJoinerInfo.output_infos)
  return output_infos_;
}

// -------------------------------------------------------------------

// SFRInfo

// int32 n = 1;
inline void SFRInfo::clear_n() {
  n_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::_internal_n() const {
  return n_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::n() const {
  // @@protoc_insertion_point(field_get:stream.SFRInfo.n)
  return _internal_n();
}
inline void SFRInfo::_internal_set_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  n_ = value;
}
inline void SFRInfo::set_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:stream.SFRInfo.n)
}

// int32 rows = 2;
inline void SFRInfo::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::rows() const {
  // @@protoc_insertion_point(field_get:stream.SFRInfo.rows)
  return _internal_rows();
}
inline void SFRInfo::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void SFRInfo::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:stream.SFRInfo.rows)
}

// int32 cols = 3;
inline void SFRInfo::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SFRInfo::cols() const {
  // @@protoc_insertion_point(field_get:stream.SFRInfo.cols)
  return _internal_cols();
}
inline void SFRInfo::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void SFRInfo::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:stream.SFRInfo.cols)
}

// -------------------------------------------------------------------

// ProcessorsInfo

// .stream.SFRInfo sfr_info = 1;
inline bool ProcessorsInfo::_internal_has_sfr_info() const {
  return this != internal_default_instance() && sfr_info_ != nullptr;
}
inline bool ProcessorsInfo::has_sfr_info() const {
  return _internal_has_sfr_info();
}
inline void ProcessorsInfo::clear_sfr_info() {
  if (GetArenaForAllocation() == nullptr && sfr_info_ != nullptr) {
    delete sfr_info_;
  }
  sfr_info_ = nullptr;
}
inline const ::stream::SFRInfo& ProcessorsInfo::_internal_sfr_info() const {
  const ::stream::SFRInfo* p = sfr_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::stream::SFRInfo&>(
      ::stream::_SFRInfo_default_instance_);
}
inline const ::stream::SFRInfo& ProcessorsInfo::sfr_info() const {
  // @@protoc_insertion_point(field_get:stream.ProcessorsInfo.sfr_info)
  return _internal_sfr_info();
}
inline void ProcessorsInfo::unsafe_arena_set_allocated_sfr_info(
    ::stream::SFRInfo* sfr_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sfr_info_);
  }
  sfr_info_ = sfr_info;
  if (sfr_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stream.ProcessorsInfo.sfr_info)
}
inline ::stream::SFRInfo* ProcessorsInfo::release_sfr_info() {
  
  ::stream::SFRInfo* temp = sfr_info_;
  sfr_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::stream::SFRInfo* ProcessorsInfo::unsafe_arena_release_sfr_info() {
  // @@protoc_insertion_point(field_release:stream.ProcessorsInfo.sfr_info)
  
  ::stream::SFRInfo* temp = sfr_info_;
  sfr_info_ = nullptr;
  return temp;
}
inline ::stream::SFRInfo* ProcessorsInfo::_internal_mutable_sfr_info() {
  
  if (sfr_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::stream::SFRInfo>(GetArenaForAllocation());
    sfr_info_ = p;
  }
  return sfr_info_;
}
inline ::stream::SFRInfo* ProcessorsInfo::mutable_sfr_info() {
  ::stream::SFRInfo* _msg = _internal_mutable_sfr_info();
  // @@protoc_insertion_point(field_mutable:stream.ProcessorsInfo.sfr_info)
  return _msg;
}
inline void ProcessorsInfo::set_allocated_sfr_info(::stream::SFRInfo* sfr_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sfr_info_;
  }
  if (sfr_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::stream::SFRInfo>::GetOwningArena(sfr_info);
    if (message_arena != submessage_arena) {
      sfr_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sfr_info, submessage_arena);
    }
    
  } else {
    
  }
  sfr_info_ = sfr_info;
  // @@protoc_insertion_point(field_set_allocated:stream.ProcessorsInfo.sfr_info)
}

// repeated .stream.TableReaderInfo tablereader_infos = 2;
inline int ProcessorsInfo::_internal_tablereader_infos_size() const {
  return tablereader_infos_.size();
}
inline int ProcessorsInfo::tablereader_infos_size() const {
  return _internal_tablereader_infos_size();
}
inline void ProcessorsInfo::clear_tablereader_infos() {
  tablereader_infos_.Clear();
}
inline ::stream::TableReaderInfo* ProcessorsInfo::mutable_tablereader_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.ProcessorsInfo.tablereader_infos)
  return tablereader_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::TableReaderInfo >*
ProcessorsInfo::mutable_tablereader_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.ProcessorsInfo.tablereader_infos)
  return &tablereader_infos_;
}
inline const ::stream::TableReaderInfo& ProcessorsInfo::_internal_tablereader_infos(int index) const {
  return tablereader_infos_.Get(index);
}
inline const ::stream::TableReaderInfo& ProcessorsInfo::tablereader_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.ProcessorsInfo.tablereader_infos)
  return _internal_tablereader_infos(index);
}
inline ::stream::TableReaderInfo* ProcessorsInfo::_internal_add_tablereader_infos() {
  return tablereader_infos_.Add();
}
inline ::stream::TableReaderInfo* ProcessorsInfo::add_tablereader_infos() {
  ::stream::TableReaderInfo* _add = _internal_add_tablereader_infos();
  // @@protoc_insertion_point(field_add:stream.ProcessorsInfo.tablereader_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::TableReaderInfo >&
ProcessorsInfo::tablereader_infos() const {
  // @@protoc_insertion_point(field_list:stream.ProcessorsInfo.tablereader_infos)
  return tablereader_infos_;
}

// repeated .stream.HashJoinerInfo hashjoiner_infos = 3;
inline int ProcessorsInfo::_internal_hashjoiner_infos_size() const {
  return hashjoiner_infos_.size();
}
inline int ProcessorsInfo::hashjoiner_infos_size() const {
  return _internal_hashjoiner_infos_size();
}
inline void ProcessorsInfo::clear_hashjoiner_infos() {
  hashjoiner_infos_.Clear();
}
inline ::stream::HashJoinerInfo* ProcessorsInfo::mutable_hashjoiner_infos(int index) {
  // @@protoc_insertion_point(field_mutable:stream.ProcessorsInfo.hashjoiner_infos)
  return hashjoiner_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::HashJoinerInfo >*
ProcessorsInfo::mutable_hashjoiner_infos() {
  // @@protoc_insertion_point(field_mutable_list:stream.ProcessorsInfo.hashjoiner_infos)
  return &hashjoiner_infos_;
}
inline const ::stream::HashJoinerInfo& ProcessorsInfo::_internal_hashjoiner_infos(int index) const {
  return hashjoiner_infos_.Get(index);
}
inline const ::stream::HashJoinerInfo& ProcessorsInfo::hashjoiner_infos(int index) const {
  // @@protoc_insertion_point(field_get:stream.ProcessorsInfo.hashjoiner_infos)
  return _internal_hashjoiner_infos(index);
}
inline ::stream::HashJoinerInfo* ProcessorsInfo::_internal_add_hashjoiner_infos() {
  return hashjoiner_infos_.Add();
}
inline ::stream::HashJoinerInfo* ProcessorsInfo::add_hashjoiner_infos() {
  ::stream::HashJoinerInfo* _add = _internal_add_hashjoiner_infos();
  // @@protoc_insertion_point(field_add:stream.ProcessorsInfo.hashjoiner_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::stream::HashJoinerInfo >&
ProcessorsInfo::hashjoiner_infos() const {
  // @@protoc_insertion_point(field_list:stream.ProcessorsInfo.hashjoiner_infos)
  return hashjoiner_infos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace stream

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::stream::StreamInfo_StreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream::StreamInfo_StreamType>() {
  return ::stream::StreamInfo_StreamType_descriptor();
}
template <> struct is_proto_enum< ::stream::TableReaderInfo_RouterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream::TableReaderInfo_RouterType>() {
  return ::stream::TableReaderInfo_RouterType_descriptor();
}
template <> struct is_proto_enum< ::stream::TableReaderInfo_TableReaderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream::TableReaderInfo_TableReaderType>() {
  return ::stream::TableReaderInfo_TableReaderType_descriptor();
}
template <> struct is_proto_enum< ::stream::HashJoinerInfo_HJType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream::HashJoinerInfo_HJType>() {
  return ::stream::HashJoinerInfo_HJType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stream_2eproto
